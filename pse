#!/bin/bash

# Author: Steve Stonebraker
# Github: https://github.com/ssstonebraker/Pentest-Service-Enumeration
# Description: Store/retrieve a list of pentest commands to run against the specified service
#
#
#set -eo pipefail
# shellcheck disable=SC3028 # $RANDOM variable is undefined.
# shellcheck disable=SC2148 # shebang does not exist. because this script will work both "zsh" and "bash".
# shellcheck disable=SC2162 #  will mangle backslashes. it does not important for now.
# shellcheck disable=SC2068,SC2128,SC2086,SC2124,SC2294,SC2145,SC2198 # TODO about $* $@
# shellcheck disable=SC2059 # printf wrapper warning.
# shellcheck disable=SC2155 # command may give error. variable assignment should be in another line.
# shellcheck disable=SC2016 # single vs double quotes
# shellcheck disable=SC1004 # line splitting is true. we need both linefeed+ empty spaces.
# shellcheck disable=SC2046 # all cases are valid. word splitting is not important in those cases. 
chars='[ !"#$&()*,;<>?\^`{|}]'
for arg
do
    if [[ $arg == *\'* ]]
    then
        arg=\""$arg"\"
    elif [[ $arg == *$chars* ]]
    then
        arg="'$arg'"
    fi
    allargs+=("$arg")    # ${allargs[@]} is to be used only for printing
done
printf '%s\n' "${allargs[*]}" > "/tmp/pse-$USER.tmp"


VERSION=0.0.3
####################################
# Exit if program echo does not exist (this allows us to do one line if statements)
[ ! -x "$(which echo)" ] && exit 1
########################################
# pretty printing functions
LIGHT_CYAN="\e[96m"
NO_COLOR="\x1B[0m"
ITALICS="\x1B[01;3m"
function print_status { echo -e "\x1B[01;34m[*]\x1B[0m $1"; }
function print_good { echo -e "\x1B[01;32m[*]\x1B[0m $1"; }
function print_error { echo -e "\x1B[01;31m[*]\x1B[0m $1"; }
function print_notification { echo -e "\x1B[01;33m[*]\x1B[0m $1"; }
function print_notify { echo -e "\x1B[01;33m[*]\x1B[0m $1"; }
function print_info { echo -e "${LIGHT_CYAN}[-]${NO_COLOR} $1"; }
function print_italics { echo -e "${ITALICS}$1${NO_COLOR}"; }
ansi()      { echo -e "\e[${1}m${*:2}\e[0m"; }
bold()      { ansi 1 "$@"; }
italic()    { ansi 3 "$@"; }
underline()   { ansi 4 "$@"; }
strikethrough() { ansi 9 "$@"; }
red()       { ansi 31 "$@"; }
function printline { hr=----------------------------------------------------------------------------------------------------
printf '%s\n' "${hr:0:${COLUMNS:-$(tput cols)}}"
}

####################################
# print message and exit program
function die { print_error "$1" >&2;exit 1; }
######################################## 

SERVICE=$1

# old verbose code
#if [[ "$SERVICE" ==  "-v" ]]; then
#    _V=1
#    SERVICE=$2
#else
#    _V=0
#fi

SERVICE=$1

# look for short description mode
if [[ "$SERVICE" ==  "-s" ]]; then
    SERVICE=$2
    _S=1
else
     #set verbose mode automatically
    _V=1
    _S=0
fi



FULLCMD=${@:2}
SERVICES="$HOME/.pse"
SERVICEFILE="$HOME/.pse/$SERVICE"

___stdout() {
   printf "%s" "$*" 
}

print_version () {
  echo "[Pentest Service Enumeration: $VERSION]"
}

function create_some_services {

___stdout 'Launch a semi-interactive shell:smbexec.py $HOST/$USERNAME:$PASSWORD@$IP
List smb share files using a null user:smbclient -L $IP -U -N
ngrep samba version while connecting via smbclient:export INTERFACE="tun0"; sudo ngrep -i -d $INTERFACE 's.?a.?m.?b.?a.*[[:digit:]]'
Recursive directory listing:smbmap -H $ip -R
Create a destination mount directory, mount remote share as guest:sudo mkdir /mnt/$IP_$FOLDER; sudo mount -v -t cifs "//$IP/$FOLDER" /mnt/$IP_$FOLDER -o username=guest
connect to remote smb share as null user:smbclient "//$IP/$SHARE_NAME" -U ""
Scan IP Address for SMB Pipe Names:pipef -a $IP' >> "$SERVICES/smb"

___stdout 'Brute Force FTP for a specific username:ftp hydra -I -t 10 -l $USERNAME -P $PW_LIST -vV $IP ftp' >> "$SERVICES/ftp"

___stdout 'Directory Discovery (medium) - ignore 404, 403, 301:FILE="/usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt"; wfuzz -c -z file,"$FILE" --hc 404,403,301 "$URL"
Directory Discovery (medium) - ignore 404, 301:FILE="/usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt"; wfuzz -c -z file,"$FILE" --hc 404,301 "$URL"
Directory Discovery (large) - ignore 404, 403, 301:FILE="/usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt"; wfuzz -c -z file,"$FILE" --hc 404,403,301 "$URL"
Directory Discovery (large) - ignore 404, 301:FILE="/usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt"; wfuzz -c -z file,"$FILE" --hc 404,301 "$URL"
File discovery:wfuzz -c -z file,/usr/share/seclists/Discovery/Web-Content/raft-medium-files.txt --hc 301,404,403 "$URL"
POST data fuzzing (password cracking):wfuzz -c -z file,/usr/share/seclists/Passwords/xato-net-10-million-passwords-100000.txt --hc 404 -d "log=admin&pwd=FUZZ" http://target:80/wp-login.php
Param value fuzzing (usernames):http://target:80/index.php?fpv=FUZZ; wfuzz -c -z file,/usr/share/seclists/Usernames/cirt-default-usernames.txt --hc 404 "$URL"
Param value fuzzing (find hidden params):export URL="http://target:80/index.php?FUZZ=data";wfuzz -c -z file,/usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt --hc 404,301 "$URL"
Command injection:URL="http://target:80/php/blocklisted.php?ip=127.0.0.1FUZZ"; wfuzz -c -z file,/home/kali/command_injection_custom.txt --hc 404 "$URL"' >> "$SERVICES/wfuzz"

___stdout 'show available nfs mounts:showmount -e $IP
mount a nfs share:export IP=10.11.1.72; sudo mkdir -p /mnt/$IP/home && sudo mount -t nfs $IP:/home /mnt/$IP/home' >> "$SERVICES/nfs"
}

function verify_directory_services_exists {
  # Make sure services directory exists
  if [ -z "$HOME" ]; then
     print_error "\$HOME variable not defined!"
     print_notification "Exiting"
     exit 1
  fi
  if [ ! -d "$SERVICES" ]; then
    print_notification "$SERVICES not found"
    mkdir "$SERVICES" && print_good "Created $SERVICES"  
    [ ! -d "$SERVICES" ] && print_error "Unable to create directory $SERVICES, exiting" && exit 1
    create_some_services
  fi

}



function print_service_names {
underline "Available Services"
SERVICES_FILES=($(ls ~/.pse | grep -v ".sorted" | grep -v ".conf"))

for item in "${SERVICES_FILES[@]}"; do
    print_good "$item"
done

}

function usage1 {
  print_version
  print_italics "- Pentest command reference via the cli"
  printline
  print_service_names
  printline
  bold "Return command references for a service"
  echo "Usage: pse <service-name>"
  echo ""
  underline "Examples"
  print_good "pse ftp"
  print_good "pse wfuzz"
  print_good "pse smb"
  echo ""
  printline
  echo "Help: pse -h"
}

function usage2 {
  printline
  bold "STORING A NEW COMMAND WITH ARGUMENTS"
  print_info "pse stored service location: ${SERVICES}"
  print_italics "Edit corresponding service file at ${SERVICES}/<filename> (e.g. ${SERVICES}/smb or ${SERVICES}/dns)"
  print_italics "If your want to add a new service, create a file in ${SERVICES}"
  echo ""

        printline
         SERVICE="curl"
         bold "Example: To create documentation for $SERVICE:"
         echo "1. Create file $SERVICES/$SERVICE"
         echo "2. Add one line per command you want saved in format:"
         print_italics "<description>:<command>"
         echo ""
         underline "Example content for file $SERVICES/$SERVICE:"
         echo "Return help content:${SERVICE} -h"
         echo "Run ${SERVICE} in verbose mode:${SERVICE} -v"

}
function usage  {
  usage1
}


function check_if_service_exists {
 if [[  "$SERVICE" ==  "-h" ]]; then
    usage1
    usage2
    exit
  fi 

  if [[ ! -f "$SERVICEFILE" ]]; then
         print_error "Documentation does not exist for $SERVICE"
         printline
         bold "To create documentation for $SERVICE:"
         echo "1. Create file $SERVICES/$SERVICE"
         echo "2. Add one line per command you want saved in format:"
         print_italics "<description>:<command>"
         echo ""
         underline "Example content for file $SERVICES/$SERVICE:"
         echo "Return help content:${SERVICE} -h"
         echo "Run ${SERVICE} in verbose mode:${SERVICE} -v"
	 exit
  fi


}
function print_service {

check_if_service_exists 

# Actually Print Service Info
    print_version
    printline
    [ -f "$SERVICEFILE.sorted" ] && rm "$SERVICEFILE.sorted" 2>/dev/null
    sort "$SERVICEFILE" > "$SERVICEFILE.sorted"
    SORTED="$SERVICEFILE.sorted"
    while IFS="" read -r p || [ -n "$p" ]
    do
    DESCRIPTION=$(echo "$p" | awk -F: '{ print $1 }')
    if [[ "$_S" -eq 0 ]]; then
      print_italics "$DESCRIPTION"
    fi
   COMMAND=$(echo $p | sed "s/$DESCRIPTION://g")
    print_good "$COMMAND"
    printline
    done < "$SORTED"
    [ -f "$SERVICEFILE.sorted" ] && rm "$SERVICEFILE.sorted" 2>/dev/null
  exit
}



# start execution
  verify_directory_services_exists
  [ $# -eq 0 ]  && usage && exit
  [ $# -eq 1 ] && print_service

  if [[ $_V -eq 1 ]]; then
    print_service
  fi



